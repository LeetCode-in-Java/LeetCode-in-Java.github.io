[![](https://img.shields.io/github/stars/javadev/LeetCode-in-Java?label=Stars&style=flat-square)](https://github.com/javadev/LeetCode-in-Java)
[![](https://img.shields.io/github/forks/javadev/LeetCode-in-Java?label=Fork%20me%20on%20GitHub%20&style=flat-square)](https://github.com/javadev/LeetCode-in-Java/fork)

## 2875\. Minimum Size Subarray in Infinite Array

Medium

You are given a **0-indexed** array `nums` and an integer `target`.

A **0-indexed** array `infinite_nums` is generated by infinitely appending the elements of `nums` to itself.

Return _the length of the **shortest** subarray of the array_ `infinite_nums` _with a sum equal to_ `target`_._ If there is no such subarray return `-1`.

**Example 1:**

**Input:** nums = [1,2,3], target = 5

**Output:** 2

**Explanation:** In this example infinite\_nums = [1,2,3,1,2,3,1,2,...]. The subarray in the range [1,2], has the sum equal to target = 5 and length = 2. It can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.

**Example 2:**

**Input:** nums = [1,1,1,2,3], target = 4

**Output:** 2

**Explanation:** In this example infinite\_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...]. The subarray in the range [4,5], has the sum equal to target = 4 and length = 2. It can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.

**Example 3:**

**Input:** nums = [2,4,6,8], target = 3

**Output:** -1

**Explanation:** In this example infinite\_nums = [2,4,6,8,2,4,6,8,...]. It can be proven that there is no subarray with sum equal to target = 3.

**Constraints:**

*   <code>1 <= nums.length <= 10<sup>5</sup></code>
*   <code>1 <= nums[i] <= 10<sup>5</sup></code>
*   <code>1 <= target <= 10<sup>9</sup></code>

## Solution

```java
public class Solution {
    public int minSizeSubarray(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum == 0) {
            return -1;
        }
        int result = (target / sum) * nums.length;
        sum = target % sum;
        int currentSum = 0;
        int min = nums.length;
        int start = 0;
        for (int i = 0; i < nums.length * 2; i++) {
            currentSum += nums[i % nums.length];
            while (currentSum > sum) {
                currentSum -= nums[start % nums.length];
                start++;
            }
            if (currentSum == sum) {
                min = Math.min(min, i - start + 1);
            }
        }
        if (min == nums.length) {
            return -1;
        }
        return result + min;
    }
}
```